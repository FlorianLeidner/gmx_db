import os
import re
import subprocess

from subprocess import PIPE

from utils.hpcc import get_scheduler

# TODO This should at some point be moved to a separate settings file
GSUBMIT_BIN = '/usr/local/bin/g_submit'

_description = """
Funcions dealing with gromacs/g_submit jobs.

The <app>_run functions call a specific app (e.g. gmx grompp; g_submit)

For consistency, all jobs will return: returncode, stdout

The <app>_out functions return a dictionary of expected outfiles

gsubnmit_batchids will return all jobids associated with a specific g_submit run
gsubmit_auxfiles will return all jobscripts and logs associated with a specific g_submit run
"""


def _gsubmit_jobscripts(out, scheduler=None):
    """
    Parse stdout of g_submit and return the jobscripts
    :param out: stdout as generated by g_submit
    :param scheduler: Which scheduler was used (Slurm/SGE) currently only SGE is supported
    :return:
    """

    cwd = os.getcwd()
    if scheduler == 'SGE':

        jobscript_regexp = r'(?<=FILENAME )(.+)'
        jobscripts = []

        lines = out.split('\n')
        for line in lines:
            match = re.search(jobscript_regexp, line)
            if match is not None:
                jobscripts.append(os.path.join(cwd, match.groups()[0]))
                continue
        return jobscripts
    elif scheduler == 'Slurm':
        jobscript_regexp = r'(?<=FILENAME )(.+)'
        jobscripts = []

        lines = out.split('\n')
        for line in lines:
            match = re.search(jobscript_regexp, line)
            if match is not None:
                jobscripts.append(os.path.join(cwd, match.groups()[0]))
                continue
        return jobscripts
    else:
        raise NotImplementedError(f'Not implemented for: {scheduler}')


def _gsubmit_jobnames(out, scheduler=None):
    """
    Parse the g_submit stdout and return the jobnames
    :param out: stdout as generated by g_submit
    :param scheduler: Which scheduler was used (Slurm/SGE) currently only SGE is supported
    :return:
    """

    if scheduler == 'SGE':
        jobname_regexp = r'(?:\")(.*)(?=\"\) has been submitted)'

        jobnames = []
        lines = out.split('\n')
        for line in lines:
            match = re.search(jobname_regexp, line)
            if match is not None:
                jobnames.append(match.groups()[0])
        return jobnames


def gsubmit_batch_ids(out):
    """
    Parse the output of g_submit which is slightly different on Slurm and SGE
    :param out:
    :return:
    """
    scheduler = get_scheduler()

    if scheduler == 'Slurm':
        regexp = r'(?<=Submitted batch job )(\d+)'
        batch_ids = []
        lines = out.split('\n')
        for line in lines:
            match = re.search(regexp, line)
            if match is not None:
                batch_ids.append(int(match.group(0)))
        return batch_ids
    elif scheduler == 'SGE':
        regexp = r'(?<=Your job )(\d+)'
        batch_ids = []
        lines = out.split('\n')
        for line in lines:
            match = re.search(regexp, line)
            if match is not None:
                batch_ids.append(int(match.group(0)))
        return batch_ids


def gsubmit_run(args):
    """
    submit simulation
    :param args:
    :return:
    """
    bin = GSUBMIT_BIN
    arg_str = ' '.join([f'{k} {i}' for k, i in args.items()])
    out = subprocess.run(f'{bin} {arg_str}', shell=True, stdout=PIPE, stderr=PIPE)

    if out.returncode:
        return out.returncode, out.stderr.decode('UTF-8')
    # Get the batch job ids
    else:
        return out.returncode, out.stdout.decode('UTF-8')


def gsubmit_auxfiles(out):
    """
    Compile all auxfiles generated by g_submit these are:
        - Jobscript(s)
        - Scheduler log file(s)
    :param out:
    :return:
    """
    scheduler = get_scheduler()
    cwd = os.getcwd()

    jobscripts = _gsubmit_jobscripts(out, scheduler=scheduler)
    joblogs = []
    batch_ids = gsubmit_batch_ids(out)

    if scheduler == 'SGE':
        jobnames = _gsubmit_jobnames(out, scheduler=scheduler)
        for bid, name in zip(batch_ids, jobnames):
            joblogs.append(os.path.join(cwd, f'{name}.o{bid}'))
            joblogs.append(os.path.join(cwd, f'{name}.e{bid}'))
            joblogs.append(os.path.join(cwd, f'{name}.po{bid}'))
            joblogs.append(os.path.join(cwd, f'{name}.pe{bid}'))
    elif scheduler == 'Slurm':
        for bid in batch_ids:
            joblogs.append(os.path.join(cwd, f'slurm-{bid}.out'))
    else:
        raise NotImplementedError(f'Not implemented for {scheduler}')
    return {'JSCRIPTS': jobscripts, 'JLOGS': joblogs}


def gsubmit_out(kwargs, base='./', outfiles=None):
    """
    Parse a list of arguments passed to g_submit and return a dictionary of all the output files
    :param kwargs:
    :param base:
    :param outfiles: A outfile dictionary
    :type outfiles: dict
    :return:
    """
    ft_gsubmit = {'-o': 'OUT',
                  '-eo': 'XVG'}
    deffnm = None
    for kw, arg in kwargs.items():
        ft = ft_gsubmit.get(kw)
        if kw == '-deffnm':
            deffnm = arg
        elif ft is not None:
            if not os.path.isabs(arg):
                outfiles[ft] = os.path.join(base, arg)
            else:
                outfiles[ft] = arg
    if deffnm is None:
        #  FIXME Depending on the .mdp file, runs can generate either a .trr, a .xtc or both types of trajectories
        outfiles['XTC'] = os.path.join(base, 'traj.xtc')
        outfiles['TRR'] = os.path.join(base, 'traj.trr')
        outfiles['CPT'] = os.path.join(base, 'state.cpt')
        outfiles['EDR'] = os.path.join(base, 'ener.edr')
        outfiles['GRO'] = os.path.join(base, 'confout.gro')
        outfiles['LOG'] = os.path.join(base, 'md.log')
    else:
        #  FIXME Depending on the .mdp file, runs can generate either a .trr, a .xtc or both types of trajectories
        outfiles['XTC'] = os.path.join(base, f'{deffnm}.xtc')
        outfiles['TRR'] = os.path.join(base, f'{deffnm}.trr')
        outfiles['CPT'] = os.path.join(base, f'{deffnm}.cpt')
        outfiles['EDR'] = os.path.join(base, f'{deffnm}.edr')
        outfiles['GRO'] = os.path.join(base, f'{deffnm}.gro')
        outfiles['LOG'] = os.path.join(base, f'{deffnm}.log')
    return outfiles


def grompp_run(args):
    """
    Run grompp
    :param args:
    :return:
    """
    arg_str = ' '.join([f'{k} {i}' for k, i in args.items()])

    out = subprocess.run(f'gmx grompp {arg_str}', shell=True, stdout=PIPE, stderr=PIPE)

    if out.returncode:
        return out.returncode, out.stderr.decode('UTF-8')
    else:
        return out.returncode, out.stdout.decode('UTF-8')


def grompp_out(kwargs, base='./', outfiles=None):
    """
    Parse a list of arguments passed to grompp and return a dictionary of all the output files
    :param kwargs:
    :param base:
    :param outfiles: A outfile dictionary
    :type outfiles: dict
    :return:
    """
    ft_grompp = {'-po': 'MDP',
                 '-pp': 'TOP',
                 '-o': 'TPR',
                 '-imd': 'GRO'}

    for kw, arg in kwargs.items():
        ft = ft_grompp.get(kw)
        if ft is not None:
            if not os.path.isabs(arg):
                outfiles[ft] = os.path.join(base, arg)
            else:
                outfiles[ft] = arg

    return outfiles


def shell_run(args):
    """
    Run generic command
    :param args:
    :return:
    """
    #  The JSONB datatype does not maintain the sequence of a list
    #  Consequently we need to make sure that the value of "cmd" is prepended to any other argument
    cmd = ''
    for k, v in args.items():
        if k == 'cmd':
            cmd = f'{v} {cmd}'
        else:
            cmd = f'{cmd} {k} {v}'

    out = subprocess.run(cmd, shell=True, stdout=PIPE, stderr=PIPE)

    if out.returncode:
        return out.returncode, out.stderr.decode('UTF-8')
    else:
        return out.returncode, out.stdout.decode('UTF-8')


def shell_out(kwargs, base='./', outfiles=None):
    """
    For generic shell commands we will return an  empty dictionary, outfiles have to be specified in the config
    :param kwargs:
    :param base:
    :param outfiles: A outfile dictionary
    :type outfiles: dict
    :return:
    """
    return outfiles
